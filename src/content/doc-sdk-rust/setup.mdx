---
sidebar_position: 2
sidebar_label: Setup
title: Rust | SDKs | Integration
description: The SurrealDB SDK for Rust enables simple and advanced querying of a remote or embedded database.
---

import Image from "@components/Image.astro";
import LightLogo from "@img/light/rust.png";
import DarkLogo from "@img/rust-icon.png";
import Label from "@components/shared/Label.astro";

<Image
    alt="Rust"
    width={100}
    className="flag-image-title"
    src={{
        light: LightLogo,
        dark: DarkLogo,
    }}
/>

# Rust SDK

### Install the SDK

First, create a new project using `cargo new` and add the following dependencies:

* `surrealdb`
* `tokio`, in order to to use the database inside `fn main()`, likely with the `macros` and `rt-multi-thread` enabled so that the `#[tokio::main]` attribute can be used on top of `fn main()`.
* `serde` with the `derive` feature enabled in order to use the `Serialize` and `Deserialize` attribute macros on top of your Rust data types to match those sent to and returned from the database.

All together, that leads to the following commands to get started.

```sh
cargo new my_project
cd my_project
cargo add surrealdb
cargo add tokio --features macros,rt-multi-thread
cargo add serde --features derive
```

The examples inside this SDK manual assume that all of these crates and features are present.

### Start SurrealDB

Before using `cargo run` to try out your code, make sure that the SurrealDB server is running with a command such as the following that will start an in-memory server with a single root user at the default address `127.0.0.1:8000`.

```bash
surreal start --user root --pass root
```

If you have Surrealist installed locally, you can also use the [`Start serving`](/docs/surrealist/concepts/local-database-serving) button to do the same.

### Connect to SurrealDB

Open `src/main.rs` and replace everything in there with the following code to try out some basic operations using the SurrealDB SDK.

```rust
use surrealdb::engine::remote::ws::Ws;
use surrealdb::opt::auth::Root;
use surrealdb::Surreal;

#[tokio::main]
async fn main() -> surrealdb::Result<()> {

    // Connect to the server
    let db = Surreal::new::<Ws>("127.0.0.1:8000").await?;

    // Signin as a namespace, database, or root user
    db.signin(Root {
        username: "root",
        password: "root",
    })
    .await?;

    // Select a specific namespace / database
    db.use_ns("test").use_db("test").await?;

    let some_queries = db.query("
        RETURN 9; 
        RETURN 10; 
        SELECT * FROM { is: 'Nice database' };
    ").await?;
    dbg!(some_queries);
    Ok(())
}
```

Note that the `.query()` method is able to hold more than one statement, in this case three. The `results` field from the `Response` struct returned contains a field called `results` which holds the results of each statement. Note that each result has its own index. This will become useful when using the `.take()` method in the example to follow.

```bash
    results: {
        0: (
            Stats {
                execution_time: Some(
                    64.125µs,
                ),
            },
            Ok(
                Number(
                    Int(
                        9,
                    ),
                ),
            ),
        ),
        1: (
            Stats {
                execution_time: Some(
                    19.791µs,
                ),
            },
            Ok(
                Number(
                    Int(
                        10,
                    ),
                ),
            ),
        ),
        2: (
            Stats {
                execution_time: Some(
                    97.75µs,
                ),
            },
            Ok(
                Array(
                    Array(
                        [
                            Object(
                                Object(
                                    {
                                        "is": Strand(
                                            Strand(
                                                "Nice database",
                                            ),
                                        ),
                                    },
                                ),
                            ),
                        ],
                    ),
                ),
            ),
        ),
    }
```

Now that we have the basics down, it is time to try out some other methods like [CREATE](/docs/surrealql/statements/create) and [UPDATE](/docs/surrealql/statements/update). The most ergonomic way to do this is to use a struct that implements `Serialize` for anything we want to pass in, and `Deserialize` for anything we have received from the database and want to turn back into a Rust type.

```rust
use serde::{Deserialize, Serialize};
use surrealdb::engine::remote::ws::Ws;
use surrealdb::opt::auth::Root;
use surrealdb::sql::Thing;
use surrealdb::Surreal;

#[derive(Debug, Serialize)]
struct Name<'a> {
    first: &'a str,
    last: &'a str,
}

#[derive(Debug, Serialize)]
struct Person<'a> {
    title: &'a str,
    name: Name<'a>,
    marketing: bool,
}

#[derive(Debug, Serialize)]
struct Responsibility {
    marketing: bool,
}

#[derive(Debug, Deserialize)]
struct Record {
    id: Thing,
}

#[tokio::main]
async fn main() -> surrealdb::Result<()> {
    let db = Surreal::new::<Ws>("127.0.0.1:8000").await?;

    db.signin(Root {
        username: "root",
        password: "root",
    })
    .await?;

    db.use_ns("test").use_db("test").await?;

    // Create a new person with a random id
    let created: Option<Record> = db
        .create("person")
        .content(Person {
            title: "Founder & CEO",
            name: Name {
                first: "Tobie",
                last: "Morgan Hitchcock",
            },
            marketing: true,
        })
    .await?;
    dbg!(created);

    // Update a person record with a specific id
    let _: Option<Record> = db
        .update(("person", "jaime"))
        .merge(Responsibility { marketing: true })
        .await?;

    // Select all people records
    let people: Vec<Record> = db.select("person").await?;
    dbg!(people);

    // Perform a custom advanced query
    let mut groups = db
        .query("SELECT marketing, count() FROM type::table($table) GROUP BY marketing")
        .bind(("table", "person"))
        .await?;
    // Use .take() to transform the first query result into
    // anything that can be deserialized, in this case
    // a Value
    dbg!(groups.take::<Value>(0).unwrap());

    Ok(())
}
```

### Other ways to see the results

Besides printing out the results inside the Rust code above, you can sign in to the database using the CLI or Surrealist to view them.

```bash
surreal sql --user root --pass root --namespace test --database test --pretty
```

Inside Surrealist, do the following:

* Hover over the current connection and click on "Change connection"
* Hover over "New connection" and click the pencil icon
* Change the "Method" to "root". Enter "root" for both username and password.
* You will now be connected as the root user, and can define and then select the namespace and databases called "test".

Here is the last query in the example above to get started:

```surql
SELECT marketing, count() FROM person GROUP BY marketing;
```

### SDK methods

The Rust SDK comes with a number of built-in functions.

<table>
    <thead>
        <tr>
            <th scope="col">Function</th>
            <th scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td scope="row" data-label="Function"><a href="#init"><code>Surreal::init()</code></a></td>
            <td scope="row" data-label="Description">Initialises a static database engine</td>
        </tr>
        <tr>
            <td scope="row" data-label="Function"><a href="#connect"><code>db.connect(endpoint)</code></a></td>
            <td scope="row" data-label="Description">Connects to a specific database endpoint, saving the connection on the static client</td>
        </tr>
        <tr>
            <td scope="row" data-label="Function"><a href="#new"><code>{"Surreal::new::<T>(endpoint)"}</code></a></td>
            <td scope="row" data-label="Description">Connects to a local or remote database endpoint</td>
        </tr>
        <tr>
            <td scope="row" data-label="Function"><a href="#use-ns-db"><code>db.use_ns(namespace).use_db(database)</code></a></td>
            <td scope="row" data-label="Description">Switch to a specific namespace and database</td>
        </tr>
        <tr>
            <td scope="row" data-label="Function"><a href="#signup"><code>db.signup(credentials)</code></a></td>
            <td scope="row" data-label="Description">Signs up a user to a specific authentication scope</td>
        </tr>
        <tr>
            <td scope="row" data-label="Function"><a href="#signin"><code>db.signin(credentials)</code></a></td>
            <td scope="row" data-label="Description">Signs this connection in to a specific authentication scope</td>
        </tr>
        <tr>
            <td scope="row" data-label="Function"><a href="#invalidate"><code>db.invalidate()</code></a></td>
            <td scope="row" data-label="Description">Invalidates the authentication for the current connection</td>
        </tr>
        <tr>
            <td scope="row" data-label="Function"><a href="#authenticate"><code>db.authenticate(token)</code></a></td>
            <td scope="row" data-label="Description">Authenticates the current connection with a JWT token</td>
        </tr>
        <tr>
            <td scope="row" data-label="Function"><a href="#set"><code>db.set(key, val)</code></a></td>
            <td scope="row" data-label="Description">Assigns a value as a parameter for this connection</td>
        </tr>
        <tr>
            <td scope="row" data-label="Function"><a href="#query"><code>db.query(sql)</code></a></td>
            <td scope="row" data-label="Description">Runs a set of SurrealQL statements against the database</td>
        </tr>
        <tr>
            <td scope="row" data-label="Function"><a href="#select"><code>db.select(resource)</code></a></td>
            <td scope="row" data-label="Description">Selects all records in a table, or a specific record</td>
        </tr>
        <tr>
            <td scope="row" data-label="Function"><a href="#selectlive"><code>db.select(resource).live()</code></a></td>
            <td scope="row" data-label="Description"> Initiate live queries for live stream of notifications</td>
        </tr>
        <tr>
            <td scope="row" data-label="Function"><a href="#create"><code>db.create(resource).content(data)</code></a></td>
            <td scope="row" data-label="Description">Creates a record in the database</td>
        </tr>
        <tr>
            <td scope="row" data-label="Function"><a href="#update-content"><code>db.update(resource).content(data)</code></a></td>
            <td scope="row" data-label="Description">Updates all records in a table, or a specific record</td>
        </tr>
        <tr>
            <td scope="row" data-label="Function"><a href="#update-merge"><code>db.update(resource).merge(data)</code></a></td>
            <td scope="row" data-label="Description">Modifies all records in a table, or a specific record</td>
        </tr>
        <tr>
            <td scope="row" data-label="Function"><a href="#update-patch"><code>db.update(resource).patch(data)</code></a></td>
            <td scope="row" data-label="Description">Applies JSON Patch changes to all records in a table, or a specific record</td>
        </tr>
        <tr>
            <td scope="row" data-label="Function"><a href="#delete"><code>db.delete(resource)</code></a></td>
            <td scope="row" data-label="Description">Deletes all records, or a specific record</td>
        </tr>
    </tbody>
</table>

<br />

## `.init()` {#init}

The DB static singleton in the examples below ensures that a single database instance is available across very large or complicated applications. With the singleton, only one connection to the database is instantiated, and the database connection does not have to be shared across components or controllers.

```rust title="Method Syntax"
Surreal::init()
```

### Example usage
```rust
static DB: LazyLock<Surreal<Client>> = LazyLock::new(Surreal::init);

#[tokio::main]
async fn main() -> surrealdb::Result<()> {
    // Connect to the database
    DB.connect::<Wss>("cloud.surrealdb.com").await?;
    // Select a namespace + database
    DB.use_ns("test").use_db("test").await?;
    // Create or update a specific record
    let tobie: Option<Record> = DB
        .update(("person", "tobie"))
        .content(Person { name: "Tobie" })
        .await?;
    Ok(())
}
```

<br />

## `.connect()` {#connect}

Connects to a local or remote database endpoint.

```rust title="Method Syntax"
db.connect(endpoint)
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>endpoint</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The database endpoint to connect to.
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```rust
static DB: LazyLock<Surreal<Client>> = LazyLock::new(Surreal::init);

use std::sync::LazyLock;
use surrealdb::engine::remote::ws::{Client, Ws, Wss};
use surrealdb::Surreal;

#[tokio::main]
async fn main() -> surrealdb::Result<()> {
    // Connect to a local endpoint
    DB.connect::<Ws>("127.0.0.1:8000").await?;
    // Connect to a remote endpoint
    DB.connect::<Wss>("cloud.surrealdb.com").await?;
    Ok(())
}
```

<br />

## `.new()` {#new}

Connects to a local or remote database endpoint.

```rust title="Method Syntax"
Surreal::new::<T>(endpoint)
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>endpoint</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The database endpoint to connect to.
            </td>
        </tr>
    </tbody>
</table>

### Example usage

```rust
use surrealdb::engine::remote::ws::Ws;
use surrealdb::Surreal;

#[tokio::main]
async fn main() -> surrealdb::Result<()> {
    let db = Surreal::new::<Ws>("127.0.0.1:8000").await?;
    Ok(())
}
```

<br />

## `.use_ns()` and `.use_db()` {#use-ns-db}

Switch to a specific namespace and database.

```rust title="Method Syntax"
db.use_ns(ns).use_db(db)
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>ns</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Switches to a specific namespace.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>db</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Switches to a specific database.
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```rust
use surrealdb::engine::remote::ws::Ws;
use surrealdb::Surreal;

#[tokio::main]
async fn main() -> surrealdb::Result<()> {
    let db = Surreal::new::<Ws>("127.0.0.1:8000").await?;
    db.use_ns("ns").use_db("db").await?;
    Ok(())
}
```

## `.signup()` {#signup}

Signs up as a record user (formerly known as a scope user) to a specific access method.

```rust title="Method Syntax"
db.signup(credentials)
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>credentials</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Variables used in a signup query.
            </td>
        </tr>
    </tbody>
</table>

### Example usage

```rust
// Use the following statement to set up the access
// 
//  DEFINE ACCESS account ON DATABASE TYPE RECORD
// 	SIGNUP ( CREATE user SET email = $email, pass = crypto::argon2::generate($pass) )
// 	SIGNIN ( SELECT * FROM user WHERE email = $email AND crypto::argon2::compare(pass, $pass) )
// 	DURATION FOR TOKEN 15m, FOR SESSION 12h
// ;

use serde::Serialize;
use surrealdb::engine::remote::ws::Ws;
use surrealdb::opt::auth::Record;
use surrealdb::Surreal;

#[derive(Serialize)]
struct Credentials<'a> {
    email: &'a str,
    pass: &'a str,
}

#[tokio::main]
async fn main() -> surrealdb::Result<()> {
    let db = Surreal::new::<Ws>("127.0.0.1:8000").await?;
    let jwt = db
        .signup(Record {
            namespace: "test",
            database: "test",
            access: "account",
            params: Credentials {
                email: "info@surrealdb.com",
                pass: "123456",
            },
        })
        .await?;

    // ⚠️: It is important to note that the token should be handled securely and protected from unauthorized access.
    let token = jwt.as_insecure_token();
    dbg!(token);
    Ok(())
}
```

## `.signin()` {#signin}

Signs in to a specific authentication scope.

```rust title="Method Syntax"
db.signin(credentials)
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>credentials</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Variables used in a signin query.
            </td>
        </tr>
    </tbody>
</table>

### Example usage

```rust
// Use the following statement to set up the access
//
// DEFINE ACCESS account ON DATABASE TYPE RECORD
// 	SIGNUP ( CREATE user SET email = $email, pass = crypto::argon2::generate($pass) )
// 	SIGNIN ( SELECT * FROM user WHERE email = $email AND crypto::argon2::compare(pass, $pass) )
// 	DURATION FOR TOKEN 15m, FOR SESSION 12h
// ;

use serde::Serialize;
use surrealdb::engine::remote::ws::Ws;
use surrealdb::opt::auth::Record;
use surrealdb::Surreal;

#[derive(Serialize)]
struct Credentials<'a> {
    email: &'a str,
    pass: &'a str,
}

#[tokio::main]
async fn main() -> surrealdb::Result<()> {
    let db = Surreal::new::<Ws>("127.0.0.1:8000").await?;
    let jwt = db
        .signin(Record {
            namespace: "test",
            database: "test",
            access: "account",
            params: Credentials {
                email: "info@surrealdb.com",
                pass: "123456",
            },
        })
        .await?;

    // ⚠️: It is important to note that the token should be handled securely and protected from unauthorized access.
    let token = jwt.as_insecure_token();
    dbg!(token);
    Ok(())
}
```

<br />

## `.invalidate()` {#invalidate}

Invalidates the authentication for the current connection.

```rust title="Method Syntax"
db.invalidate()
```

### Example usage
```surql
db.invalidate().await?;
```

<br />

## `.authenticate()` {#authenticate}

Authenticates the current connection with a JWT token.

```rust title="Method Syntax"
db.authenticate(token)
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>token</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The JWT authentication token.
            </td>
        </tr>
    </tbody>
</table>

### Example usage

Note: the following example uses the `ureq` crate with the ["json"] feature to first send a request to the database's [`/signup`](/docs/surrealdb/integration/http#signup) endpoint which returns a token. The `reqwest` crate and others can be used here instead.

Alternatively, you could use a command like `curl -X POST -H "Accept: application/json" -d '{"ns":"test","db":"test","ac":"account","user":"info@surrealdb.com","pass":"123456"}' http://localhost:8000/signup`, copy the returned token, and paste it into the `.authenticate()` method. As the `DEFINE ACCESS` method below shows, a token will remain valid by default for 15 minutes.

```rust
// Use the following statement to set up the access
//
// DEFINE ACCESS account ON DATABASE TYPE RECORD
// 	SIGNUP ( CREATE user SET email = $email, pass = crypto::argon2::generate($pass) )
// 	SIGNIN ( SELECT * FROM user WHERE email = $email AND crypto::argon2::compare(pass, $pass) )
// 	DURATION FOR TOKEN 15m, FOR SESSION 12h
// ;

// DEFINE TABLE cat SCHEMALESS
//     PERMISSIONS for select, update, delete, create
//     WHERE $auth.id;

use serde::Deserialize;
use std::fmt::Display;
use surrealdb::engine::remote::ws::Ws;
use surrealdb::Surreal;

#[derive(Deserialize)]
struct Response {
    token: String,
}

impl Display for Response {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.token)
    }
}

#[tokio::main]
async fn main() -> surrealdb::Result<()> {
    let db = Surreal::new::<Ws>("127.0.0.1:8000").await?;
    let token = ureq::post("http://127.0.0.1:8000/signup")
        .set("Accept", "application/json")
        .send_json(ureq::json!({
            "ns": "test",
            "db": "test",
            "ac": "account",
            "email": "info@surrealdb.com",
            "pass": "123456"
        }))
        .unwrap()
        .into_json::<Response>()
        .unwrap()
        .to_string();

    // Not signed in, doesn't work
    dbg!(db.query("CREATE cat;").await?);
    db.authenticate(token).await?;
    // Now it works
    dbg!(db.query("CREATE cat;").await?);

    Ok(())
}
```

<br />

## `.set()` {#set}

Assigns a value as a parameter for this connection.

```rust title="Method Syntax"
db.set(key, val)
```

This is equivalent to using a [`LET`](https://surrealdb.com/docs/surrealql/statements/let) statement in SurrealQL.

```surql
LET $name = {
    first: "Tobie",
    last: "Morgan Hitchcock",
};
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>key</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Specifies the name of the variable.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>val</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Assigns the value to the variable name.
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```rust
// Assign the variable on the connection
db.set("name", Name {
    first: "Tobie",
    last: "Morgan Hitchcock",
}).await?;
// Use the variable in a subsequent query
db.query("CREATE person SET name = $name").await?;
// Use the variable in a subsequent query
db.query("SELECT * FROM person WHERE name.first = $name.first").await?;
```

<br />

## `.query()` {#query}

Runs one or more SurrealQL statements against the database.

```rust title="Method Syntax"
db.query(sql).bind(vars)
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>sql</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Specifies the SurrealQL statements.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>vars</code>
               <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                Assigns variables which can be used in the query.
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```rust
// Run some queries
let sql = "
    CREATE person;
    SELECT * FROM type::table($table);
";
let mut result = db
    .query(sql)
    .bind(("table", "person"))
    .await?;
// Get the first result from the first query
let created: Option<Person> = result.take(0)?;
// Get all of the results from the second query
let people: Vec<Person> = result.take(1)?;
```

<br />

## `.select()` {#select}

Selects all records in a table, or a specific record, from the database.

```rust title="Method Syntax"
db.select(resource)
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>resource</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The table name or a record ID to select.
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```rust
// Select all records from a table
let people: Vec<Person> = db.select("person").await?;
// Select a specific record from a table
let person: Option<Person> = db.select(("person", "h5wxrf2ewk8xjxosxtyc")).await?;
```

### Example usage: Retrieve unique id of a record
```rust
use serde::Deserialize;
use surrealdb::engine::remote::ws::Ws;
use surrealdb::opt::auth::Root;
use surrealdb::sql::Id;
use surrealdb::Surreal;

//  defining your own custom Thing struct and using that in place of `Thing` in the `Id` struct
#[derive(Debug, Deserialize)]
struct CustomThing {
	id: Id,
}

#[derive(Debug, Deserialize)]
struct Person {
	id: CustomThing,
	name: String,
	age: u8,
}

#[tokio::main]
async fn main() -> surrealdb::Result<()> {
	// Connect to the database
	let db = Surreal::new::<Ws>("localhost:8000").await?;

	// Sign in
	db.signin(Root {
		username: "root",
		password: "root",
	})
	.await?;

	// Select namespace and database to use
	db.use_ns("namespace").use_db("database").await?;

	// Create a person
	db.query("CREATE person:john SET name = 'John Doe', age = 25").await?.check()?;

	// Query that person
	let john: Option<Person> = db.select(("person", "john")).await?;
	dbg!(john);

	Ok(())
}

```

### Translated query
This function will run the following query in the database:

```surql
SELECT * FROM $resource;
```

<br />

## `.select().live()` {#selectlive}

Initiate live queries for live stream of notifications.

```rust title="Method Syntax"
db.select(resource).live()
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>resource</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The table name or a record ID to select.
            </td>
        </tr>
    </tbody>
</table>

### Example usage: Listen for live updates

```rust
// Select the "person" table and listen for live updates.
    let mut stream = db.select("person").live().await?;

    // Process updates as they come in.
    while let Some(result) = stream.next().await {
        // Do something with the notification
        handle(result);
    }

    // Handle the result of the live query notification
    fn handle(result: Result<Notification<Person>>) {
        println!("Received notification: {:?}", result);
    }
```
<br />

## `.create()` {#create}

Creates a record in the database.

```rust title="Method Syntax"
db.create(resource).content(data)
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>resource</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The table name or the specific record ID to create.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>data</code>
               <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The document / record data to insert.
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```rust
// Create a record with a random ID
let person: Option<Person> = db.create("person").await?;
// Create a record with a specific ID
let record: Option<Record> = db
    .create(("person", "tobie"))
    .content(Person {
        name: "Tobie",
        settings: {
            active: true,
            marketing: true,
       },
    }).await?;
```

### Translated query
This function will run the following query in the database:

```surql
CREATE $resource CONTENT $data;
```

<br />

## `.update().content()` {#update-content}

Updates all records in a table, or a specific record, in the database.

```rust title="Method Syntax"
db.update(resource).content(data)
```

> [!NOTE]
> This function replaces the current document / record data with the specified data.

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>resource</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The table name or the specific record ID to create.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>data</code>
               <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The document / record data to insert.
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```rust
// Update all records in a table
let people: Vec<Person> = db.update("person").await?;
// Update a record with a specific ID
let person: Option<Person> = db
    .update(("person", "tobie"))
    .content(Person {
        name: "Tobie",
        settings: {
            active: true,
            marketing: true,
        },
    }).await?;
```

### Translated query
This function will run the following query in the database:

```surql
UPDATE $resource CONTENT $data;
```

<br />

## `.update().merge()` {#update-merge}

Modifies all records in a table, or a specific record, in the database.

```rust title="Method Syntax"
db.update(resource).merge(data)
```

> [!NOTE]
> This function merges the current document / record data with the specified data.

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>resource</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The table name or the specific record ID to create.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>data</code>
               <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The document / record data to insert.
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```rust
// Update all records in a table
let people: Vec<Person> = db.update("person")
    .merge(Document {
        updated_at: Datetime::default(),
    })
    .await?;
// Update a record with a specific ID
let person: Option<Person> = db.update(("person", "tobie"))
    .merge(Document {
        updated_at: Datetime::default(),
        settings: Settings {
            active: true,
        },
    })
    .await?;
```

### Translated query
This function will run the following query in the database:

```surql
UPDATE $resource MERGE $data;
```

<br />

## `.update().patch()` {#update-patch}

Applies JSON Patch changes to all records, or a specific record, in the database.

```rust title="Method Syntax"
db.update(resource).patch(data)
```

> [!NOTE]
> This function patches the current document / record data with the specified JSON Patch data.

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>resource</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The table name or the specific record ID to modify.
            </td>
        </tr>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>data</code>
               <Label label="optional" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The JSON Patch data with which to modify the records.
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```rust
// Update all records in a table
let people: Vec<Person> = db.update("person")
    .patch(PatchOp::replace("/created_at", Datetime::default()))
    .await?;

// Update a record with a specific ID
let person: Option<Person> = db.update(("person", "tobie"))
    .patch(PatchOp::replace("/settings/active", false))
    .patch(PatchOp::add("/tags", &["developer", "engineer"]))
    .patch(PatchOp::remove("/temp"))
    .await?;
```

### Translated query
This function will run the following query in the database:

```surql
UPDATE $resource PATCH $data;
```

<br />

## `.delete()` {#delete}

Deletes all records in a table, or a specific record, from the database.

```rust title="Method Syntax"
db.delete(resource)
```

### Arguments
<table>
    <thead>
        <tr>
            <th colspan="2" scope="col">Arguments</th>
            <th colspan="2" scope="col">Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td colspan="2" scope="row" data-label="Arguments">
                <code>resource</code>
                <Label label="required" />
            </td>
            <td colspan="2" scope="row" data-label="Description">
                The table name or a record ID to select.
            </td>
        </tr>
    </tbody>
</table>

### Example usage
```rust
// Delete all records from a table
let people: Vec<Person> = db.delete("person").await?;
// Delete a specific record from a table
let person: Option<Person> = db.delete(("person", "h5wxrf2ewk8xjxosxtyc")).await?;
```

### Translated query
This function will run the following query in the database:

```surql
DELETE FROM $resource RETURN BEFORE;
```
